diff --git a/back-end/BackTop.cpp b/back-end/BackTop.cpp
index e0c2e5c..5a8aa8c 100644
--- a/back-end/BackTop.cpp
+++ b/back-end/BackTop.cpp
@@ -34,7 +34,7 @@ void BackTop::difftest_cycle() {
 
   if (commit_num > 0) {
     for (int i = 0; i < commit_num; i++) {
-      InstUop *inst = &rob->out.rob_commit->commit_entry[commit_indices[i]].uop;
+      InstInfo *inst = &rob->out.rob_commit->commit_entry[commit_indices[i]].uop;
 
       // 1. åŒæ­¥ä¾§æ•ˆåº” (Sync side effects for EVERY instruction)
       difftest_sync(inst);
@@ -89,7 +89,7 @@ void BackTop::difftest_cycle() {
 #endif
 }
 
-void BackTop::difftest_sync(InstUop *inst) {
+void BackTop::difftest_sync(InstInfo *inst) {
   if (inst->type == JALR) {
     if (inst->src1_areg == 1 && inst->dest_areg == 0 && inst->imm == 0) {
       ctx->perf.ret_br_num++;
@@ -179,7 +179,7 @@ void BackTop::difftest_sync(InstUop *inst) {
 }
 
 void BackTop::difftest_inst(InstEntry *inst_entry) {
-  InstUop *inst = &inst_entry->uop;
+  InstInfo *inst = &inst_entry->uop;
   difftest_sync(inst);
 
 #ifdef CONFIG_DIFFTEST
diff --git a/back-end/Dispatch.cpp b/back-end/Dispatch.cpp
index ef409cc..59dc79a 100644
--- a/back-end/Dispatch.cpp
+++ b/back-end/Dispatch.cpp
@@ -338,32 +338,32 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   switch (src_uop.type) {
   case ADD:
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_ADD;
     count = 1;
     break;
   case MUL:
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_MUL;
     count = 1;
     break;
   case DIV:
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_DIV;
     count = 1;
     break;
   case BR:
     out_uops[0].iq_id = IQ_BR;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_BR;
     count = 1;
     break;
 
   case LOAD:
     out_uops[0].iq_id = IQ_LD;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_LOAD;
     count = 1;
     break;
@@ -371,12 +371,12 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   case STORE:
     // æ‹†åˆ†ä¸º STA + STD
     out_uops[0].iq_id = IQ_STA;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_STA;
     out_uops[0].uop.src2_en = false; // STA åªç”¨ src1 (Base)
 
     out_uops[1].iq_id = IQ_STD;
-    out_uops[1].uop = src_uop;
+    std::memcpy(&out_uops[1].uop, &src_uop, sizeof(InstInfo));
     out_uops[1].uop.op = UOP_STD;
     out_uops[1].uop.src1_en = false; // STD æ•°æ®æºä¿®æ­£
     out_uops[1].uop.src2_en = true;  // STD åªç”¨ src2 (Data)
@@ -386,14 +386,14 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   case JALR:
     // JALR -> ADD (PC+4) + JUMP
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_ADD;
     out_uops[0].uop.imm = 4;
     out_uops[0].uop.src1_en = false; // PC+4 ä¸éœ€è¦ src1
     out_uops[0].uop.src2_en = false; // PC+4 ä¸éœ€è¦ src2
 
     out_uops[1].iq_id = IQ_BR;
-    out_uops[1].uop = src_uop;
+    std::memcpy(&out_uops[1].uop, &src_uop, sizeof(InstInfo));
     out_uops[1].uop.op = UOP_JUMP;
     out_uops[1].uop.src1_en = true; // JALR éœ€è¦ src1 (Base)
     out_uops[1].uop.dest_en = false;
@@ -403,14 +403,14 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   case JAL:
     // JAL -> ADD (PC+4) + JUMP
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     out_uops[0].uop.op = UOP_ADD;
     out_uops[0].uop.imm = 4;
     out_uops[0].uop.src1_en = false; // PC+4 ä¸éœ€è¦ src1
     out_uops[0].uop.src2_en = false; // PC+4 ä¸éœ€è¦ src2
 
     out_uops[1].iq_id = IQ_BR;
-    out_uops[1].uop = src_uop;
+    std::memcpy(&out_uops[1].uop, &src_uop, sizeof(InstInfo));
     out_uops[1].uop.op = UOP_JUMP;
     out_uops[1].uop.dest_en = false; // è·³è½¬ä¸å†™å¯„å­˜å™¨
     count = 2;
@@ -419,14 +419,14 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   case AMO:
     if ((src_uop.func7 >> 2) == AmoOp::LR) {
       out_uops[0].iq_id = IQ_LD;
-      out_uops[0].uop = src_uop;
+      std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
       out_uops[0].uop.op = UOP_LOAD;
       out_uops[0].uop.src2_en = false;
       count = 1;
     } else if ((src_uop.func7 >> 2) == AmoOp::SC) {
       // SC -> INT(0) + STA + STD
       out_uops[0].iq_id = IQ_INT;
-      out_uops[0].uop = src_uop;
+      std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
       out_uops[0].uop.op =
           UOP_ADD; // é¢„è®¾ 0 (å‡å®šæˆåŠŸï¼ŒLSUä¼šè¦†ç›–? æˆ–è€…è¿™é‡Œä»…ä»…æ˜¯å ä½)
                    // å®é™… SC çš„è¿”å›å€¼ç”± LSU Writeback å†³å®šï¼Œé€šå¸¸æ˜¯ Store
@@ -438,13 +438,13 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
       out_uops[0].uop.src2_en = false;
 
       out_uops[1].iq_id = IQ_STA;
-      out_uops[1].uop = src_uop;
+      std::memcpy(&out_uops[1].uop, &src_uop, sizeof(InstInfo));
       out_uops[1].uop.op = UOP_STA;
       out_uops[1].uop.src2_en = false;
       out_uops[1].uop.dest_en = false; // Fix: STA ä¸å†™å›å¯„å­˜å™¨
 
       out_uops[2].iq_id = IQ_STD;
-      out_uops[2].uop = src_uop;
+      std::memcpy(&out_uops[2].uop, &src_uop, sizeof(InstInfo));
       out_uops[2].uop.op = UOP_STD;
       out_uops[2].uop.src1_en = false;
       out_uops[2].uop.dest_en = false; // Fix: STD ä¸å†™å›å¯„å­˜å™¨
@@ -452,18 +452,18 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
     } else {
       // AMO RMW -> LOAD + STA + STD
       out_uops[0].iq_id = IQ_LD;
-      out_uops[0].uop = src_uop;
+      std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
       out_uops[0].uop.op = UOP_LOAD;
       out_uops[0].uop.src2_en = false;
 
       out_uops[1].iq_id = IQ_STA;
-      out_uops[1].uop = src_uop;
+      std::memcpy(&out_uops[1].uop, &src_uop, sizeof(InstInfo));
       out_uops[1].uop.op = UOP_STA;
       out_uops[1].uop.src2_en = false;
       out_uops[1].uop.dest_en = false; // Fix: STA ä¸å†™å›å¯„å­˜å™¨
 
       out_uops[2].iq_id = IQ_STD;
-      out_uops[2].uop = src_uop;
+      std::memcpy(&out_uops[2].uop, &src_uop, sizeof(InstInfo));
       out_uops[2].uop.op = UOP_STD;
       // å‡è®¾ SDU è´Ÿè´£è®¡ç®—ï¼Œéœ€è¦åŸ dest_preg ä½œä¸ºæ“ä½œæ•° (æ•°æ®æº)
       // æ³¨æ„: è¿™é‡Œ src1_preg è¢«è®¾ä¸º dest_pregï¼Œç”¨äºè¯»å–å†…å­˜æ—§å€¼è¿›è¡ŒåŸå­è¿ç®—?
@@ -494,7 +494,7 @@ int Dispatch::decompose_inst(const InstEntry &inst, UopPacket *out_uops) {
   // æ”¹ç¼–è‡ªï¼šNOP, CSR, ç­‰
   default: // NOP, CSR, ç­‰
     out_uops[0].iq_id = IQ_INT;
-    out_uops[0].uop = src_uop;
+    std::memcpy(&out_uops[0].uop, &src_uop, sizeof(InstInfo));
     // ç‰¹æ®ŠæŒ‡ä»¤èµ°æ•´æ•°é˜Ÿåˆ— (IQ_INT)
     switch (src_uop.type) {
     case NOP:
diff --git a/back-end/Exu/Exu.cpp b/back-end/Exu/Exu.cpp
index eb161f8..b09bc93 100644
--- a/back-end/Exu/Exu.cpp
+++ b/back-end/Exu/Exu.cpp
@@ -277,7 +277,7 @@ void Exu::comb_exec() {
   int fu_global_idx = 0; // ç”¨äºç»™æ¯ä¸ª FU ç¼–å·
   // éå†æ‰€æœ‰ FU å•å…ƒ
   for (auto fu : units) {
-    InstUop *res = fu->get_finished_uop(); // çœ‹çœ‹è¿™ä¸ª FU ç®—å®Œæ²¡
+    MicroOp *res = fu->get_finished_uop(); // çœ‹çœ‹è¿™ä¸ª FU ç®—å®Œæ²¡
 
     if (res) {
       // âœ… æ— è®ºæ˜¯å¦èƒ½å†™å›ï¼Œå…ˆå¹¿æ’­å‡ºå»ç»™ Bypass ç”¨ï¼
@@ -294,7 +294,7 @@ void Exu::comb_exec() {
       AbstractFU *fu = map_entry.fu;
 
       // æ£€æŸ¥è¿™ä¸ª FU æœ‰æ²¡æœ‰ç»“æœåå‡ºæ¥
-      InstUop *res = fu->get_finished_uop();
+      MicroOp *res = fu->get_finished_uop();
 
       if (res) {
         if (out.exe2prf->entry[p_idx].valid) {
@@ -343,7 +343,7 @@ void Exu::comb_exec() {
   // LSU çš„ Load ç»“æœ
   for (int i = 0; i < LSU_LOAD_WB_WIDTH; i++) {
     if (in.lsu2exe->wb_req[i].valid) {
-      InstUop &load_uop = in.lsu2exe->wb_req[i].uop;
+      MicroOp &load_uop = in.lsu2exe->wb_req[i].uop;
 
       int wb_port_idx = IQ_LD_PORT_BASE + i;
 
@@ -359,7 +359,7 @@ void Exu::comb_exec() {
   // [æ–°å¢] LSU çš„ STA ç»“æœ (å¸¦ Page Fault)
   for (int i = 0; i < LSU_STA_COUNT; i++) {
     if (in.lsu2exe->sta_wb_req[i].valid) {
-      InstUop &sta_uop = in.lsu2exe->sta_wb_req[i].uop;
+      MicroOp &sta_uop = in.lsu2exe->sta_wb_req[i].uop;
 
       int wb_port_idx = IQ_STA_PORT_BASE + i;
 
diff --git a/back-end/Exu/include/AbstractFU.h b/back-end/Exu/include/AbstractFU.h
index d0ed4be..685fa71 100644
--- a/back-end/Exu/include/AbstractFU.h
+++ b/back-end/Exu/include/AbstractFU.h
@@ -22,7 +22,7 @@ public:
 
   // === 2. æ¥æ”¶æŒ‡ä»¤ (Issue Stage è°ƒç”¨) ===
   // åŠ¨ä½œï¼šå¡è¿›å»
-  virtual void accept(InstUop inst) = 0;
+  virtual void accept(MicroOp inst) = 0;
 
   // === 3. æ—¶é’Ÿæ­¥è¿› (Execute Stage è°ƒç”¨) ===
   // åŠ¨ä½œï¼šå†…éƒ¨çŠ¶æ€æµè½¬ä¸€æ‹
@@ -31,7 +31,7 @@ public:
   // === 4. è·å–ç»“æœ (Writeback Stage è°ƒç”¨) ===
   // é—®ï¼šè¿™ä¸€æ‹æœ‰åšå®Œçš„æŒ‡ä»¤å—ï¼Ÿ
   // æ³¨æ„ï¼šè¿”å›æŒ‡é’ˆï¼Œå¦‚æœä¸º nullptr è¡¨ç¤ºæ²¡ç»“æœ
-  virtual InstUop *get_finished_uop() = 0;
+  virtual MicroOp *get_finished_uop() = 0;
 
   // åŠ¨ä½œï¼šç»“æœè¢«å–èµ°äº†ï¼Œä» FU é‡Œç§»é™¤å®ƒ
   virtual void pop_finished() = 0;
@@ -43,7 +43,7 @@ public:
 class FixedLatencyFU : public AbstractFU {
 protected:
   int latency;
-  std::deque<InstUop> pipeline;
+  std::deque<MicroOp> pipeline;
 
 public:
   FixedLatencyFU(std::string n, int port_idx, int lat)
@@ -58,7 +58,7 @@ public:
     return pipeline.size() < limit;
   }
 
-  void accept(InstUop inst) override {
+  void accept(MicroOp inst) override {
     // 1. ç«‹å³æ‰§è¡ŒåŠŸèƒ½è®¡ç®— (Magic Execution)
     //    è™½ç„¶ç¡¬ä»¶æ˜¯åœ¨å»¶è¿Ÿç»“æŸåæ‰å‡ºç»“æœï¼Œä½†æ¨¡æ‹Ÿå™¨é‡Œä¸ºäº†æ–¹ä¾¿ï¼Œ
     //    é€šå¸¸åœ¨å…¥é˜Ÿæ—¶å°±ç›´æ¥ç®—å¥½ç»“æœå­˜åœ¨ inst é‡Œã€‚
@@ -86,7 +86,7 @@ public:
       // ä½¿ç”¨è¿­ä»£å™¨éå† deque
       auto it = pipeline.begin();
       while (it != pipeline.end()) {
-        // å‡è®¾ InstUop æœ‰ br_mask åŸŸ (ä¾èµ–æ©ç ) æˆ– tag åŸŸ
+        // å‡è®¾ MicroOp æœ‰ br_mask åŸŸ (ä¾èµ–æ©ç ) æˆ– tag åŸŸ
         // æ£€æŸ¥ï¼šå¦‚æœæŒ‡ä»¤ä¾èµ–äºè¢«è¯¯é¢„æµ‹çš„åˆ†æ”¯
         if ((1ULL << it->tag) & br_mask) { // æˆ–è€… check dependency mask
           it = pipeline.erase(it);
@@ -97,7 +97,7 @@ public:
     }
   }
 
-  InstUop *get_finished_uop() override {
+  MicroOp *get_finished_uop() override {
     // For latency=1 FUs, instruction completes in the SAME cycle it's accepted
     // cplt_time = sim_time + latency - 1 = sim_time + 1 - 1 = sim_time
     // The newest instruction (back) is the one that just completed!
@@ -124,13 +124,13 @@ public:
 
 protected:
   // === æ ¸å¿ƒé’©å­ï¼šå­ç±»å¿…é¡»å®ç°å…·ä½“çš„è®¡ç®—é€»è¾‘ ===
-  virtual void impl_compute(InstUop &inst) = 0;
+  virtual void impl_compute(MicroOp &inst) = 0;
 };
 
 class IterativeFU : public AbstractFU {
 protected:
   int remaining_cycles;
-  InstUop current_inst; // è¿­ä»£å•å…ƒé€šå¸¸æ˜¯éæµæ°´åŒ–çš„ï¼ŒæŒæœ‰ä¸€ä¸ª latch å³å¯
+  MicroOp current_inst; // è¿­ä»£å•å…ƒé€šå¸¸æ˜¯éæµæ°´åŒ–çš„ï¼ŒæŒæœ‰ä¸€ä¸ª latch å³å¯
   bool busy;
   int max_latency;
 
@@ -143,7 +143,7 @@ public:
     return !busy; // å¿™åˆ™æ‹’æ”¶
   }
 
-  void accept(InstUop inst) override {
+  void accept(MicroOp inst) override {
     // === 1. åŠŸèƒ½è®¡ç®— (Functional) ===
     // åœ¨è¿™é‡Œè°ƒç”¨è™šå‡½æ•°ï¼Œè®¡ç®— result = src1 / src2
     impl_compute(inst);
@@ -166,7 +166,7 @@ public:
     }
   }
 
-  InstUop *get_finished_uop() override {
+  MicroOp *get_finished_uop() override {
     if (busy && remaining_cycles == 0) {
       return &current_inst;
     }
@@ -198,10 +198,10 @@ public:
 
 protected:
   // 1. è´Ÿè´£ç®—â€œç»“æœæ˜¯å¤šå°‘â€ (Common for all FUs)
-  virtual void impl_compute(InstUop &inst) = 0;
+  virtual void impl_compute(MicroOp &inst) = 0;
 
   // 2. è´Ÿè´£ç®—â€œè€—æ—¶å¤šä¹…â€ (Specific to IterativeFU)
-  virtual int calculate_latency(const InstUop &inst) {
+  virtual int calculate_latency(const MicroOp &inst) {
     return max_latency; // é»˜è®¤è¿”å›æœ€å¤§å»¶è¿Ÿ
   }
 };
diff --git a/back-end/Exu/include/Exu.h b/back-end/Exu/include/Exu.h
index 40e73ee..57765ee 100644
--- a/back-end/Exu/include/Exu.h
+++ b/back-end/Exu/include/Exu.h
@@ -63,8 +63,8 @@ public:
   std::vector<AbstractFU *> units;
 
   // pipeline registers
-  InstEntry inst_r[ISSUE_WIDTH];   // å½“å‰æ‰§è¡Œçº§æŒ‡ä»¤
-  InstEntry inst_r_1[ISSUE_WIDTH]; // ä¸‹ä¸€å‘¨æœŸæŒ‡ä»¤ (Latch)
+  UopEntry inst_r[ISSUE_WIDTH];   // å½“å‰æ‰§è¡Œçº§æŒ‡ä»¤
+  UopEntry inst_r_1[ISSUE_WIDTH]; // ä¸‹ä¸€å‘¨æœŸæŒ‡ä»¤ (Latch)
                                    //
 private:
   bool issue_stall[ISSUE_WIDTH];
diff --git a/back-end/Exu/include/Fu.h b/back-end/Exu/include/Fu.h
index 80c0b76..880b0f3 100644
--- a/back-end/Exu/include/Fu.h
+++ b/back-end/Exu/include/Fu.h
@@ -24,7 +24,7 @@ public:
       : FixedLatencyFU(name, port_idx, 1) {}
 
 protected:
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     uint32_t operand1, operand2;
     if (inst.src1_is_pc)
       operand1 = inst.pc;
@@ -105,7 +105,7 @@ public:
 
 protected:
   int get_lsu_port_id() override { return this->agu_port_idx; }
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     // 1. è®¡ç®—è™šæ‹Ÿåœ°å€ (Common logic)
     // Load å’Œ Store (STA) éƒ½éœ€è¦è®¡ç®—åœ°å€ï¼š Base + Offset
     uint64_t vaddr = inst.src1_rdata + inst.imm;
@@ -140,7 +140,7 @@ public:
 
 protected:
   int get_lsu_port_id() override { return this->sdu_port_idx; }
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     uint32_t result_data = 0;
 
     // === 1. è·å–æ“ä½œæ•° & è®¡ç®— Store Data ===
@@ -174,10 +174,10 @@ protected:
         result_data = op1 | op2;
         break;
       case AmoOp::MIN:
-        result_data = ((int64_t)op1 < (int64_t)op2) ? op1 : op2;
+        result_data = ((int32_t)op1 < (int32_t)op2) ? op1 : op2;
         break;
       case AmoOp::MAX:
-        result_data = ((int64_t)op1 > (int64_t)op2) ? op1 : op2;
+        result_data = ((int32_t)op1 > (int32_t)op2) ? op1 : op2;
         break;
       case AmoOp::MINU:
         result_data = (op1 < op2) ? op1 : op2;
@@ -211,7 +211,7 @@ public:
       : FixedLatencyFU(name, port_idx, lat) {}
 
 protected:
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     int64_t s1 = (int64_t)(int32_t)inst.src1_rdata;
     int64_t s2 = (int64_t)(int32_t)inst.src2_rdata;
     uint64_t u1 = (uint32_t)inst.src1_rdata;
@@ -254,7 +254,7 @@ public:
       : FixedLatencyFU(name, port_idx, 1), ftq(ftq) {}
 
 protected:
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     uint32_t operand1 = inst.src1_rdata;
     uint32_t operand2 = inst.src2_rdata;
     uint32_t pc_br = inst.pc + inst.imm;
@@ -342,7 +342,7 @@ public:
       : IterativeFU(name, port_idx, lat) {}
 
 protected:
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     int32_t dividend = (int32_t)inst.src1_rdata;
     int32_t divisor = (int32_t)inst.src2_rdata;
     uint32_t u_dividend = (uint32_t)inst.src1_rdata;
@@ -413,7 +413,7 @@ public:
       : FixedLatencyFU(name, port_idx, 1), exe2csr(exe2csr), csr2exe(csr2exe) {}
 
 protected:
-  void impl_compute(InstUop &inst) override {
+  void impl_compute(MicroOp &inst) override {
     if (exe2csr->re) {
       inst.result = csr2exe->rdata;
     }
diff --git a/back-end/Idu.cpp b/back-end/Idu.cpp
index 48041a8..43c4d23 100644
--- a/back-end/Idu.cpp
+++ b/back-end/Idu.cpp
@@ -10,7 +10,7 @@
 // ä¸­é—´ä¿¡å·
 static tag_t alloc_tag[FETCH_WIDTH]; // åˆ†é…çš„æ–° Tag
 
-void decode(InstUop &uop, uint32_t instructinn);
+void decode(InstInfo &uop, uint32_t instructinn);
 
 void Idu::init() {
   for (int i = 1; i < MAX_BR_NUM; i++) {
@@ -262,7 +262,7 @@ void Idu::seq() {
   }
 }
 
-void Idu::decode(InstUop &uop, uint32_t inst) {
+void Idu::decode(InstInfo &uop, uint32_t inst) {
   // æ“ä½œæ•°æ¥æºä»¥åŠtype
   // uint32_t imm;
   int uop_num = 1;
diff --git a/back-end/Isu.cpp b/back-end/Isu.cpp
index 62699cb..cbf84d6 100644
--- a/back-end/Isu.cpp
+++ b/back-end/Isu.cpp
@@ -81,7 +81,7 @@ void Isu::comb_enq() {
     for (int w = 0; w < max_w; w++) {
       // ä½¿ç”¨æ–°æ¥å£ç»“æ„ req[i][w]
       if (in.dis2iss->req[i][w].valid) {
-        InstUop &uop = in.dis2iss->req[i][w].uop;
+        MicroOp &uop = in.dis2iss->req[i][w].uop;
 
         // === åŠ è½½æŒ‡ä»¤ (Load) ä¾èµ–æ©ç ç”Ÿæˆ ===
         if (i == IQ_LD) {
@@ -113,7 +113,7 @@ void Isu::comb_enq() {
           }
         }
 
-        InstEntry new_entry;
+        UopEntry new_entry;
         new_entry.uop = uop;
         new_entry.valid = true;
         // è®°å½•å…¥é˜Ÿæ—¶é—´
diff --git a/back-end/Lsu/SimpleLsu.cpp b/back-end/Lsu/SimpleLsu.cpp
index 277c5f9..83dbc34 100644
--- a/back-end/Lsu/SimpleLsu.cpp
+++ b/back-end/Lsu/SimpleLsu.cpp
@@ -138,7 +138,7 @@ void SimpleLsu::comb_load_res() {
 }
 
 // å†…éƒ¨è¾…åŠ©: å¯åŠ¨ Load æµç¨‹ (åŸ dispatch_load)
-void SimpleLsu::handle_load_req(const InstUop &inst) {
+void SimpleLsu::handle_load_req(const MicroOp &inst) {
   // æ³¨æ„ï¼šè¿™é‡Œæ˜¯ç»„åˆé€»è¾‘ï¼Œä¸èƒ½ç›´æ¥ä¿®æ”¹ inflight_loads (è¿™æ˜¯ seq çš„çŠ¶æ€)
   // ä½†ä¸ºäº†ç®€åŒ–ä»£ç ï¼Œæˆ‘ä»¬å‡è®¾è¿™é‡Œæ˜¯ä¸€ä¸ª "Next State Logic"ï¼Œæˆ–è€…æœ‰ä¸€ä¸ª input
   // latch ä¸¥æ ¼çš„ç¡¬ä»¶æ¨¡æ‹Ÿåº”è¯¥æŠŠ task æ”¾å…¥ä¸€ä¸ª new_tasks åˆ—è¡¨ï¼Œåœ¨ seq é‡Œ merge
@@ -146,7 +146,7 @@ void SimpleLsu::handle_load_req(const InstUop &inst) {
   // è¿™é‡Œé‡‡ç”¨ç®€åŒ–åšæ³•ï¼šç›´æ¥æ“ä½œ inflight_loadsï¼Œä½†åœ¨ seq é‡Œå¤„ç†æ—¶é—´æ¨è¿›
   // åªè¦ inflight_loads ä¸è¢«å½“ä½œå¯„å­˜å™¨è¾“å‡ºå›ç¯å³å¯
 
-  InstUop task = inst;
+  MicroOp task = inst;
   task.is_cache_miss = false; // Initialize to false
   uint32_t p_addr;
   bool ret = mmu->translate(p_addr, task.result, 1, in.csr_status);
@@ -156,6 +156,8 @@ void SimpleLsu::handle_load_req(const InstUop &inst) {
     task.cplt_time = sim_time + 1;
   } else {
     task.paddr = p_addr;
+    uint32_t alignment_mask = (inst.func3 & 0x3) == 0 ? 0 : (inst.func3 & 0x3) == 1 ? 1 : 3;
+    Assert((p_addr & alignment_mask) == 0 && "DUT: Load address misaligned!");
 
     // [Fix] Disable Store-to-Load Forwarding for MMIO ranges
     // These addresses involve side effects and must read from consistent memory
@@ -183,7 +185,11 @@ void SimpleLsu::handle_load_req(const InstUop &inst) {
       if (latency >= cache.MISS_LATENCY) {
           task.is_cache_miss = true;
       }
-      uint32_t mem_val = p_memory[p_addr >> 2];
+      // Read 64 bits to handle misaligned access crossing word boundaries
+      uint64_t data_l = (uint64_t)p_memory[p_addr >> 2];
+      uint64_t data_h = (uint64_t)p_memory[(p_addr >> 2) + 1];
+      uint64_t data64 = (data_h << 32) | data_l;
+      uint32_t mem_val = (uint32_t)(data64 >> ((p_addr & 0x3) * 8));
 
       // Simple MMIO Read Interception
       // Sync with Oracle's timer to prevent execution divergence
@@ -203,7 +209,7 @@ void SimpleLsu::handle_load_req(const InstUop &inst) {
         task.difftest_skip = false;
       }
 
-      task.result = extract_data(mem_val, p_addr, inst.func3);
+      task.result = extract_data(mem_val, p_addr & ~0x3, inst.func3);
     } else {
       // ğŸ”„ [Retry] Store åœ°å€åŒ¹é…ä½†æ•°æ®æœªå°±ç»ª (Stall)
       // è®¾ç½®ç‰¹æ®Šå®Œæˆæ—¶é—´ï¼Œè®© seq ä¸­çš„é€»è¾‘ä¸æ–­é‡è¯•
@@ -215,7 +221,7 @@ void SimpleLsu::handle_load_req(const InstUop &inst) {
   inflight_loads.push_back(task);
 }
 
-void SimpleLsu::handle_store_addr(const InstUop &inst) {
+void SimpleLsu::handle_store_addr(const MicroOp &inst) {
   int idx = inst.stq_idx;
   stq[idx].addr = inst.result; // VA
   // Translate VA -> PA
@@ -225,7 +231,7 @@ void SimpleLsu::handle_store_addr(const InstUop &inst) {
   if (!ret) {
     // âš ï¸ Store Page Fault Detected!
     // Report to ROB via Writeback/Exception path
-    InstUop fault_op = inst;
+    MicroOp fault_op = inst;
     fault_op.page_fault_store = true;
     fault_op.cplt_time = sim_time; // Immediate failure
 
@@ -236,7 +242,7 @@ void SimpleLsu::handle_store_addr(const InstUop &inst) {
     // to ensure ROB only considers it complete AFTER MMU translation.
     // Given the user's advice, we will let ALL STA results go through Port 5
     // via LSU.)
-    InstUop success_op = inst;
+    MicroOp success_op = inst;
     success_op.cplt_time = sim_time;
     bool is_mmio = ((pa & UART_ADDR_MASK) == UART_ADDR_BASE) ||
                    ((pa & PLIC_ADDR_MASK) == PLIC_ADDR_BASE);
@@ -245,10 +251,12 @@ void SimpleLsu::handle_store_addr(const InstUop &inst) {
   }
 
   stq[idx].p_addr = pa;
+  uint32_t alignment_mask = (inst.func3 & 0x3) == 0 ? 0 : (inst.func3 & 0x3) == 1 ? 1 : 3;
+  Assert((pa & alignment_mask) == 0 && "DUT: Store address misaligned!");
   stq[idx].addr_valid = true;
 }
 
-void SimpleLsu::handle_store_data(const InstUop &inst) {
+void SimpleLsu::handle_store_data(const MicroOp &inst) {
   stq[inst.stq_idx].data = inst.result;
   stq[inst.stq_idx].data_valid = true;
 }
@@ -426,17 +434,37 @@ void SimpleLsu::seq() {
       // 1. å†™å†…å­˜ (Memory Access)
       cache.cache_access(head.p_addr);
       uint32_t paddr = head.p_addr;
-      uint32_t word_idx = paddr >> 2;
-      uint32_t old_val = p_memory[word_idx];
-      uint32_t new_val =
-          merge_data_to_word(old_val, head.data, paddr, head.func3);
-      p_memory[word_idx] = new_val;
+      int offset = paddr & 0x3;
+      uint32_t store_width = get_mem_width(head.func3);
+      uint32_t strobe = (store_width == 1) ? 0x1 : (store_width == 2) ? 0x3 : 0xF;
+      uint64_t wstrb64 = (uint64_t)strobe << offset;
+      uint64_t wdata64 = (uint64_t)head.data << (offset * 8);
+
+      uint32_t new_val_first_word = p_memory[paddr >> 2]; // For MMIO side effect tracking
+
+      for (int i = 0; i < 2; i++) {
+        uint32_t current_wstrb = (wstrb64 >> (i * 4)) & 0xF;
+        uint32_t current_wdata = (wdata64 >> (i * 32)) & 0xFFFFFFFF;
+        if (current_wstrb == 0) continue;
+
+        uint32_t mask = 0;
+        if (current_wstrb & 0b1) mask |= 0xFF;
+        if (current_wstrb & 0b10) mask |= 0xFF00;
+        if (current_wstrb & 0b100) mask |= 0xFF0000;
+        if (current_wstrb & 0b1000) mask |= 0xFF000000;
+
+        uint32_t old_val = p_memory[(paddr >> 2) + i];
+        uint32_t updated_val = (mask & current_wdata) | (~mask & old_val);
+        p_memory[(paddr >> 2) + i] = updated_val;
+        if (i == 0) new_val_first_word = updated_val;
+      }
+      uint32_t new_val = new_val_first_word;
 
       // Simple MMIO Write Side Effect
       if (paddr == UART_ADDR_BASE) {
         char temp = new_val & 0xFF;
         std::cout << temp << std::flush;
-        p_memory[word_idx] &= 0xFFFFFF00;
+        p_memory[paddr >> 2] &= 0xFFFFFF00;
       } else if (paddr == UART_ADDR_BASE + 1) {
         uint8_t cmd = head.data & 0xff;
         if (cmd == 7) {
@@ -582,7 +610,7 @@ bool SimpleLsu::is_store_older(int s_idx, int s_flag, int l_idx, int l_flag) {
 // ğŸ›¡ï¸ [Nanako Implementation] å®Œæ•´çš„ STLF æ¨¡æ‹Ÿé€»è¾‘
 // =========================================================
 std::pair<int, uint32_t>
-SimpleLsu::check_store_forward(uint32_t p_addr, const InstUop &load_uop) {
+SimpleLsu::check_store_forward(uint32_t p_addr, const MicroOp &load_uop) {
 
   // Load çš„èŒƒå›´
   int load_width = get_mem_width(load_uop.func3);
@@ -724,20 +752,35 @@ StqEntry SimpleLsu::get_stq_entry(int stq_idx) { return stq[stq_idx]; }
 
 uint32_t SimpleLsu::coherent_read(uint32_t p_addr) {
   // 1. åŸºå‡†å€¼ï¼šè¯»ç‰©ç†å†…å­˜
-  uint32_t data = p_memory[p_addr >> 2];
+  uint64_t data_l = (uint64_t)p_memory[p_addr >> 2];
+  uint64_t data_h = (uint64_t)p_memory[(p_addr >> 2) + 1];
+  uint64_t data64 = (data_h << 32) | data_l;
+  uint32_t data = (uint32_t)(data64 >> ((p_addr & 0x3) * 8));
 
   // 2. éå† STQ è¿›è¡Œè¦†ç›– (Coherent Check)
-  // è™½ç„¶ MMU walk é€šå¸¸æ˜¯ 4 å­—èŠ‚å¯¹é½çš„ Word è®¿é—®ï¼Œ
-  // ä½†æˆ‘ä»¬æ”¯æŒå­—èŠ‚åˆå¹¶ä»¥åº”å¯¹æ‰€æœ‰æ½œåœ¨å¯¹é½æƒ…å†µã€‚
   int ptr = stq_head;
   int count = stq_count;
   for (int i = 0; i < count; i++) {
     const auto &entry = stq[ptr];
     if (entry.valid && entry.addr_valid) {
-      // æ£€æŸ¥åœ°å€èŒƒå›´æ˜¯å¦æœ‰é‡å  (å½“å‰è®¿å­˜åœ°å€çš„æ ¸å¿ƒ Word)
-      if ((entry.p_addr & ~0x3) == (p_addr & ~0x3)) {
-        // ä½¿ç”¨ç°æœ‰çš„åˆå¹¶åŠ©æ‰‹æ›´æ–°ç»“æœ
-        data = merge_data_to_word(data, entry.data, entry.p_addr, entry.func3);
+      int store_width = get_mem_width(entry.func3);
+      uint32_t s_start = entry.p_addr;
+      uint32_t s_end = s_start + store_width;
+      
+      uint32_t load_start = p_addr;
+      uint32_t load_end = p_addr + 4; // coherent_read typically for a Word (4 bytes)
+
+      uint32_t overlap_start = (load_start > s_start) ? load_start : s_start;
+      uint32_t overlap_end = (load_end < s_end) ? load_end : s_end;
+
+      if (overlap_start < overlap_end) {
+        for (uint32_t addr = overlap_start; addr < overlap_end; addr++) {
+          int s_offset = addr - s_start;
+          int l_offset = addr - load_start;
+          uint8_t byte = (entry.data >> (s_offset * 8)) & 0xFF;
+          uint32_t mask = 0xFF << (l_offset * 8);
+          data = (data & ~mask) | ((uint32_t)byte << (l_offset * 8));
+        }
       }
     }
     ptr = (ptr + 1) % STQ_NUM;
diff --git a/back-end/Lsu/include/SimpleLsu.h b/back-end/Lsu/include/SimpleLsu.h
index db831fb..be5dcd0 100644
--- a/back-end/Lsu/include/SimpleLsu.h
+++ b/back-end/Lsu/include/SimpleLsu.h
@@ -24,13 +24,13 @@ private:
   int stq_count;
 
   // 2. æ­£åœ¨é£è¡Œçš„ Load é˜Ÿåˆ— (æ¨¡æ‹Ÿ Cache å»¶è¿Ÿ)
-  std::list<InstUop> inflight_loads;
+  std::list<MicroOp> inflight_loads;
 
   // 3. å®Œæˆçš„ Load é˜Ÿåˆ— (ç­‰å¾…å†™å›)
-  std::deque<InstUop> finished_loads;
+  std::deque<MicroOp> finished_loads;
 
   // 4. å®Œæˆçš„ STA é˜Ÿåˆ— (ç­‰å¾…è®¿å­˜æµæ°´çº¿å¯¹é½å†™å›)
-  std::deque<InstUop> finished_sta_reqs;
+  std::deque<MicroOp> finished_sta_reqs;
 
   // 4. ä¸‹ä¸€å‘¨æœŸéœ€è¦æ›´æ–°çš„çŠ¶æ€ (Latches)
   int next_stq_tail;
@@ -65,12 +65,12 @@ public:
 private:
   Csr *csr_module = nullptr;
   // å†…éƒ¨è¾…åŠ©å‡½æ•°
-  void handle_load_req(const InstUop &uop);
-  void handle_store_addr(const InstUop &uop);
-  void handle_store_data(const InstUop &uop);
+  void handle_load_req(const MicroOp &uop);
+  void handle_store_addr(const MicroOp &uop);
+  void handle_store_data(const MicroOp &uop);
   int find_recovery_tail(mask_t br_mask);
   bool is_store_older(int s_idx, int s_flag, int l_idx, int l_flag);
 
   std::pair<int, uint32_t> check_store_forward(uint32_t p_addr,
-                                                const InstUop &load_uop);
+                                                const MicroOp &load_uop);
 };
diff --git a/back-end/Prf.cpp b/back-end/Prf.cpp
index 9b3b022..c86945d 100644
--- a/back-end/Prf.cpp
+++ b/back-end/Prf.cpp
@@ -13,7 +13,7 @@ void Prf::init() {}
 void Prf::comb_br_check() {
   // æ£€æŸ¥å†™å›çº§æ˜¯å¦æœ‰è¯¯é¢„æµ‹çš„åˆ†æ”¯æŒ‡ä»¤
   bool mispred = false;
-  InstUop *mispred_uop = nullptr;
+  MicroOp *mispred_uop = nullptr;
 
   // éå†æ‰€æœ‰å†™å›æ§½ä½
   for (int i = 0; i < ISSUE_WIDTH; i++) {
@@ -54,7 +54,7 @@ void Prf::comb_read() {
   for (int i = 0; i < ISSUE_WIDTH; i++) {
     // 1. ç›´æ¥ä¼ é€’ Issue å†…å®¹
     out.prf2exe->iss_entry[i] = in.iss2prf->iss_entry[i];
-    InstEntry *entry = &out.prf2exe->iss_entry[i];
+    UopEntry *entry = &out.prf2exe->iss_entry[i];
 
     if (!entry->valid)
       continue;
diff --git a/back-end/Ren.cpp b/back-end/Ren.cpp
index 2f22fe9..87d4e31 100644
--- a/back-end/Ren.cpp
+++ b/back-end/Ren.cpp
@@ -287,7 +287,7 @@ void Ren ::comb_commit() {
         }
       }
 
-      InstUop *inst = &in.rob_commit->commit_entry[i].uop;
+      InstInfo *inst = &in.rob_commit->commit_entry[i].uop;
 
       // free_vec_normalåœ¨å¼‚å¸¸æŒ‡ä»¤æäº¤æ—¶å¯¹åº”ä½ä¸ä¼šç½®ä¸ºtrueï¼Œä¸ä¼šé‡Šæ”¾dest_aregçš„åŸæœ‰æ˜ å°„çš„å¯„å­˜å™¨
       // spec_alloc_normalåœ¨å¼‚å¸¸æŒ‡ä»¤æäº¤æ—¶å¯¹åº”ä½ä¸ä¼šç½®ä¸ºfalseï¼Œè¿™æ ·è¯¥æŒ‡ä»¤çš„dest_pregæ‰èƒ½æ­£ç¡®åœ¨free_vecä¸­è¢«å›æ”¶
diff --git a/back-end/include/BackTop.h b/back-end/include/BackTop.h
index b548c46..77b9b09 100644
--- a/back-end/include/BackTop.h
+++ b/back-end/include/BackTop.h
@@ -148,5 +148,8 @@ public:
   // debug
   void difftest_inst(InstEntry *inst_entry);
   void difftest_cycle();
-  void difftest_sync(InstUop *inst);
+  void difftest_sync(InstInfo *inst);
+  uint32_t get_reg(uint8_t arch_idx) {
+    return prf->reg_file[rename->arch_RAT_1[arch_idx]];
+  }
 };
diff --git a/back-end/include/Dispatch.h b/back-end/include/Dispatch.h
index 0530a78..aee2a51 100644
--- a/back-end/include/Dispatch.h
+++ b/back-end/include/Dispatch.h
@@ -26,7 +26,7 @@ public:
 
 struct UopPacket {
   int iq_id;   // ç›®æ ‡ IQ
-  InstUop uop; // å¾®æ“ä½œå†…å®¹
+  MicroOp uop; // å¾®æ“ä½œå†…å®¹
 };
 
 class Dispatch {
diff --git a/back-end/include/IO.h b/back-end/include/IO.h
index c0ff71d..6f68ca3 100644
--- a/back-end/include/IO.h
+++ b/back-end/include/IO.h
@@ -8,7 +8,7 @@
 
 struct DecRenIO {
 
-  InstUop uop[FETCH_WIDTH];
+  InstInfo uop[FETCH_WIDTH];
   wire<1> valid[FETCH_WIDTH];
   DecRenIO() {
     for (auto &v : uop)
@@ -126,7 +126,7 @@ struct RobDisIO {
 
 struct DisRobIO {
 
-  InstUop uop[FETCH_WIDTH];
+  InstInfo uop[FETCH_WIDTH];
   wire<1> valid[FETCH_WIDTH];
   wire<1> dis_fire[FETCH_WIDTH];
 
@@ -142,7 +142,7 @@ struct DisRobIO {
 
 struct RenDisIO {
 
-  InstUop uop[FETCH_WIDTH];
+  InstInfo uop[FETCH_WIDTH];
   wire<1> valid[FETCH_WIDTH];
 
   RenDisIO() {
@@ -172,7 +172,7 @@ struct PrfAwakeIO {
 
 struct DisIssIO {
 
-  InstEntry req[IQ_NUM][MAX_IQ_DISPATCH_WIDTH];
+  UopEntry req[IQ_NUM][MAX_IQ_DISPATCH_WIDTH];
   DisIssIO() {
     for (auto &iq_req : req)
       for (auto &r : iq_req)
@@ -238,7 +238,7 @@ struct RobBroadcastIO {
 
 struct IssPrfIO {
 
-  InstEntry iss_entry[ISSUE_WIDTH];
+  UopEntry iss_entry[ISSUE_WIDTH];
 
   IssPrfIO() {
     for (auto &v : iss_entry)
@@ -248,7 +248,7 @@ struct IssPrfIO {
 
 struct PrfExeIO {
 
-  InstEntry iss_entry[ISSUE_WIDTH];
+  UopEntry iss_entry[ISSUE_WIDTH];
 
   PrfExeIO() {
     for (auto &v : iss_entry)
@@ -258,8 +258,8 @@ struct PrfExeIO {
 
 struct ExePrfIO {
 
-  InstEntry entry[ISSUE_WIDTH];
-  InstEntry bypass[TOTAL_FU_COUNT];
+  UopEntry entry[ISSUE_WIDTH];
+  UopEntry bypass[TOTAL_FU_COUNT];
 
   ExePrfIO() {
     for (auto &v : entry)
@@ -285,7 +285,7 @@ struct ExeIssIO {
 
 struct PrfRobIO {
 
-  InstEntry entry[ISSUE_WIDTH];
+  UopEntry entry[ISSUE_WIDTH];
 
   PrfRobIO() {
     for (auto &v : entry)
@@ -386,7 +386,7 @@ struct MemReqIO {
   wire<32> wdata;
   wire<8> wstrb;
 
-  InstUop uop;
+  MicroOp uop;
 
   MemReqIO() {
     en = {};
@@ -412,7 +412,7 @@ struct MemRespIO {
   wire<32> data;
 
   wire<32> addr;
-  InstUop uop;
+  MicroOp uop;
 
   MemRespIO() {
     wen = {};
@@ -444,7 +444,7 @@ struct DcacheMshrIO {
   wire<32> wstrb;
   wire<32> wdata;
 
-  InstUop uop;
+  MicroOp uop;
 
   DcacheMshrIO() {
     valid = {};
@@ -476,7 +476,7 @@ struct DcacheWritebufferIO {
   wire<1> mispred;
   wire<BR_MASK_WIDTH> br_mask;
 
-  InstUop uop;
+  MicroOp uop;
 
   DcacheWritebufferIO() {
     valid = {};
@@ -619,8 +619,8 @@ struct LsuRobIO {
 
 struct LsuExeIO {
 
-  InstEntry wb_req[LSU_LOAD_WB_WIDTH];
-  InstEntry sta_wb_req[LSU_STA_COUNT];
+  UopEntry wb_req[LSU_LOAD_WB_WIDTH];
+  UopEntry sta_wb_req[LSU_STA_COUNT];
 
   LsuExeIO() {
     for (auto &v : wb_req)
@@ -648,8 +648,8 @@ struct DisLsuIO {
 
 struct ExeLsuIO {
 
-  InstEntry agu_req[LSU_AGU_COUNT];
-  InstEntry sdu_req[LSU_SDU_COUNT];
+  UopEntry agu_req[LSU_AGU_COUNT];
+  UopEntry sdu_req[LSU_SDU_COUNT];
 
   ExeLsuIO() {
     for (auto &v : agu_req)
diff --git a/back-end/include/Idu.h b/back-end/include/Idu.h
index 2ccadc7..3b2b18e 100644
--- a/back-end/include/Idu.h
+++ b/back-end/include/Idu.h
@@ -33,7 +33,7 @@ public:
   int max_br_per_cycle;
   IduIn in;
   IduOut out;
-  void decode(InstUop &uop, uint32_t inst);
+  void decode(InstInfo &uop, uint32_t inst);
 
   void init();
   void comb_decode();      // è¯‘ç å¹¶åˆ†é…tag
diff --git a/back-end/include/IssueQueue.h b/back-end/include/IssueQueue.h
index bac4696..99ffef3 100644
--- a/back-end/include/IssueQueue.h
+++ b/back-end/include/IssueQueue.h
@@ -31,8 +31,8 @@ public:
   int dispatch_width;
   std::vector<PortBinding> ports;
 
-  std::vector<InstEntry> entry;
-  std::vector<InstEntry> entry_1;
+  std::vector<UopEntry> entry;
+  std::vector<UopEntry> entry_1;
   int count, count_1;
 
   // Wakeup Matrix: [Physical Register] -> Bitmask of IQ slots
@@ -55,7 +55,7 @@ public:
   }
 
   // å…¥é˜Ÿ (è¿”å›æˆåŠŸå…¥é˜Ÿçš„ä¸ªæ•°)
-  int enqueue(const InstEntry &inst) {
+  int enqueue(const UopEntry &inst) {
     if (count_1 >= size)
       return 0;
     for (int i = 0; i < size; i++) {
@@ -211,10 +211,10 @@ public:
   }
 
   // ç”¨äº Store Mask æ‰«æçš„åªè¯»è®¿é—®
-  const std::vector<InstEntry> &get_entries_1() const { return entry_1; }
+  const std::vector<UopEntry> &get_entries_1() const { return entry_1; }
 
 private:
-  bool is_ready(const InstEntry &ent) {
+  bool is_ready(const UopEntry &ent) {
     const auto &op = ent.uop;
     bool ops_ok =
         (!op.src1_en || !op.src1_busy) && (!op.src2_en || !op.src2_busy);
diff --git a/back-end/include/ModuleIOs.h b/back-end/include/ModuleIOs.h
index 25df1fe..fa4defa 100644
--- a/back-end/include/ModuleIOs.h
+++ b/back-end/include/ModuleIOs.h
@@ -34,8 +34,8 @@ typedef struct DecRenUop {
   wire<1>  page_fault_inst;
   wire<1>  illegal_inst;    // éæ³•æŒ‡ä»¤å¼‚å¸¸ (Illegal Instruction)
 
-  // Filter function: Maps full InstUop to DecRenUop
-  static DecRenUop filter(const InstUop& full) {
+  // Filter function: Maps full InstInfo to DecRenUop
+  static DecRenUop filter(const InstInfo& full) {
     DecRenUop slim;
     slim.pc        = full.pc;
     slim.type      = full.type;
@@ -73,7 +73,7 @@ typedef struct RenDisUop {
   wire<1>   src1_busy;     // æº 1 å¿™çŠ¶æ€
   wire<1>   src2_busy;     // æº 2 å¿™çŠ¶æ€
 
-  static RenDisUop filter(const InstUop& full) {
+  static RenDisUop filter(const InstInfo& full) {
     RenDisUop slim;
     slim.pc            = full.pc;
     slim.base          = DecRenUop::filter(full);
@@ -103,7 +103,7 @@ typedef struct DisIssUop {
   wire<1>   src1_busy, src2_busy;
   wire<1>   src1_is_pc, src2_is_imm;
 
-  static DisIssUop filter(const InstUop& full) {
+  static DisIssUop filter(const MicroOp& full) {
     DisIssUop slim;
     slim.pc        = full.pc;
     slim.op        = full.op;
@@ -140,7 +140,7 @@ typedef struct IssExeUop {
   wire<1>  src2_is_imm;    // æ“ä½œæ•° 2 Mux
   wire<1>  illegal_inst;   // å¼‚å¸¸é€ä¼ 
 
-  static IssExeUop filter(const InstUop& full) {
+  static IssExeUop filter(const MicroOp& full) {
     IssExeUop slim;
     slim.pc        = full.pc;
     slim.op        = full.op;
@@ -170,7 +170,7 @@ typedef struct ExeWbUop {
   wire<1>  page_fault_store;
   wire<1>  flush_pipe;
 
-  static ExeWbUop filter(const InstUop& full) {
+  static ExeWbUop filter(const MicroOp& full) {
     ExeWbUop slim;
     slim.op               = full.op;
     slim.result           = full.result;
@@ -208,7 +208,7 @@ typedef struct RobUop {
   wire<1>  br_taken;
   wire<1>  mispred;
 
-  static RobUop filter(const InstUop& full) {
+  static RobUop filter(const InstInfo& full) {
     RobUop slim;
     slim.type            = full.type;
     slim.pc              = full.pc;
diff --git a/back-end/include/Prf.h b/back-end/include/Prf.h
index 1ca6484..0b7b46a 100644
--- a/back-end/include/Prf.h
+++ b/back-end/include/Prf.h
@@ -44,8 +44,8 @@ public:
 #endif
 
   reg<32> reg_file[PRF_NUM];
-  InstEntry inst_r[ISSUE_WIDTH];
+  UopEntry inst_r[ISSUE_WIDTH];
 
   wire<32> reg_file_1[PRF_NUM];
-  InstEntry inst_r_1[ISSUE_WIDTH];
+  UopEntry inst_r_1[ISSUE_WIDTH];
 };
diff --git a/back-end/include/types.h b/back-end/include/types.h
index 479bc64..ffb4d4a 100644
--- a/back-end/include/types.h
+++ b/back-end/include/types.h
@@ -65,9 +65,10 @@ typedef union {
   uint32_t pc_next;
 } RobExtraData;
 
-typedef struct InstUop {
-  wire<32> instruction; // Debug only: raw instruction bits (not for hardware logic)
-  wire<32> diag_val;    // Hardware: Shared field for instruction or pc_next
+typedef struct InstInfo {
+  wire<32>
+      instruction; // Debug only: raw instruction bits (not for hardware logic)
+  wire<32> diag_val; // Hardware: Shared field for instruction or pc_next
 
   wire<AREG_IDX_WIDTH> dest_areg, src1_areg, src2_areg;
   wire<PRF_IDX_WIDTH> dest_preg, src1_preg, src2_preg; // log2(PRF_NUM)
@@ -76,13 +77,64 @@ typedef struct InstUop {
   wire<32> result;
   wire<32> paddr;
 
-  // åˆ†æ”¯é¢„æµ‹ä¿¡æ¯
-  // wire<1> pred_br_taken; // Moved to FTQ
-  // wire<1> alt_pred;      // Moved to FTQ
-  // wire<8> altpcpn;       // Moved to FTQ
-  // wire<8> pcpn;          // Moved to FTQ
-  // wire<32> pred_br_pc;   // Moved to FTQ (next_pc)
-  // wire<32> tage_idx[4]; // TN_MAX = 4 // Moved to FTQ
+  int ftq_idx;
+  int ftq_offset;
+  bool ftq_is_last;
+
+  // åˆ†æ”¯é¢„æµ‹æ›´æ–°ä¿¡æ¯
+  wire<1> mispred;
+  wire<1> br_taken;
+
+  wire<1> dest_en, src1_en, src2_en;
+  wire<1> src1_busy, src2_busy;
+  wire<1> src1_is_pc;
+  wire<1> src2_is_imm;
+  wire<3> func3;
+  wire<7> func7;
+  wire<32> imm;
+  wire<32> pc;
+  wire<BR_TAG_WIDTH> tag;
+  wire<CSR_IDX_WIDTH> csr_idx;
+  wire<ROB_IDX_WIDTH> rob_idx;
+  wire<STQ_IDX_WIDTH> stq_idx;
+  wire<STQ_NUM> pre_sta_mask;
+
+  // ROB ä¿¡æ¯
+  wire<2> uop_num;
+  wire<2> cplt_num;
+  wire<1> rob_flag; // ç”¨äºå¯¹æ¯”æŒ‡ä»¤å¹´é¾„
+
+  // å¼‚å¸¸ä¿¡æ¯
+  wire<1> page_fault_inst;
+  wire<1> page_fault_load;
+  wire<1> page_fault_store;
+  wire<1> illegal_inst;
+
+  InstType type;
+  UopType op;
+  bool is_cache_miss;
+
+  // Debug
+  bool difftest_skip;
+  bool flush_pipe;
+  int64_t inst_idx;
+  int64_t cplt_time;
+  int64_t enqueue_time;
+
+  InstInfo() { std::memset(this, 0, sizeof(InstInfo)); }
+} InstInfo;
+
+typedef struct MicroOp {
+  wire<32>
+      instruction; // Debug only: raw instruction bits (not for hardware logic)
+  wire<32> diag_val; // Hardware: Shared field for instruction or pc_next
+
+  wire<AREG_IDX_WIDTH> dest_areg, src1_areg, src2_areg;
+  wire<PRF_IDX_WIDTH> dest_preg, src1_preg, src2_preg; // log2(PRF_NUM)
+  wire<PRF_IDX_WIDTH> old_dest_preg;
+  wire<32> src1_rdata, src2_rdata;
+  wire<32> result;
+  wire<32> paddr;
 
   int ftq_idx;
   int ftq_offset;
@@ -98,8 +150,8 @@ typedef struct InstUop {
   wire<1> src2_is_imm;
   wire<3> func3;
   wire<7> func7;
-  wire<32> imm; // å¥½åƒä¸ç”¨32bit å…ˆç”¨ç€
-  wire<32> pc;  // æœªæ¥å°†ä¼šä¼˜åŒ–pcçš„è·å–
+  wire<32> imm;
+  wire<32> pc;
   wire<BR_TAG_WIDTH> tag;
   wire<CSR_IDX_WIDTH> csr_idx;
   wire<ROB_IDX_WIDTH> rob_idx;
@@ -128,15 +180,21 @@ typedef struct InstUop {
   int64_t cplt_time;
   int64_t enqueue_time;
 
-  InstUop() { std::memset(this, 0, sizeof(InstUop)); }
-} InstUop;
+  MicroOp() { std::memset(this, 0, sizeof(MicroOp)); }
+} MicroOp;
 
 typedef struct {
   wire<1> valid;
-  InstUop uop;
+  InstInfo uop;
   RobExtraData extra_data;
 } InstEntry;
 
+typedef struct {
+  wire<1> valid;
+  MicroOp uop;
+  RobExtraData extra_data;
+} UopEntry;
+
 typedef struct {
   wire<1> valid;
   wire<PRF_IDX_WIDTH> preg;
diff --git a/back-end/include/util.h b/back-end/include/util.h
index a730d59..5a29b5c 100644
--- a/back-end/include/util.h
+++ b/back-end/include/util.h
@@ -22,12 +22,21 @@ inline uint32_t make_rob_idx(uint32_t line, uint32_t bank) {
 
 inline bool is_branch(InstType type) { return type == BR || type == JALR; }
 
-inline bool is_store(InstUop uop) {
+inline bool is_store(InstInfo uop) {
   return uop.type == STORE ||
          (uop.type == AMO && (uop.func7 >> 2) != AmoOp::LR);
 }
 
-inline bool is_load(InstUop uop) {
+inline bool is_store(MicroOp uop) {
+  return uop.type == STORE ||
+         (uop.type == AMO && (uop.func7 >> 2) != AmoOp::LR);
+}
+
+inline bool is_load(InstInfo uop) {
+  return uop.type == LOAD || (uop.type == AMO && (uop.func7 >> 2) != AmoOp::SC);
+}
+
+inline bool is_load(MicroOp uop) {
   return uop.type == LOAD || (uop.type == AMO && (uop.func7 >> 2) != AmoOp::SC);
 }
 
@@ -42,7 +51,15 @@ inline bool is_CSR_uop(UopType op) {
           op == UOP_EBREAK);
 }
 
-inline bool cmp_inst_age(InstUop inst1, InstUop inst2) {
+inline bool cmp_inst_age(InstInfo inst1, InstInfo inst2) {
+  if (inst1.rob_flag == inst2.rob_flag) {
+    return inst1.rob_idx > inst2.rob_idx;
+  } else {
+    return inst1.rob_idx < inst2.rob_idx;
+  }
+}
+
+inline bool cmp_inst_age(MicroOp inst1, MicroOp inst2) {
   if (inst1.rob_flag == inst2.rob_flag) {
     return inst1.rob_idx > inst2.rob_idx;
   } else {
@@ -56,16 +73,31 @@ inline bool is_std_uop(UopType op) { return op == UOP_STD; }
 
 inline bool is_load_uop(UopType op) { return op == UOP_LOAD; }
 
-inline bool is_page_fault(InstUop uop) {
+inline bool is_page_fault(InstInfo uop) {
+  return uop.page_fault_inst || uop.page_fault_load || uop.page_fault_store;
+}
+
+inline bool is_page_fault(MicroOp uop) {
   return uop.page_fault_inst || uop.page_fault_load || uop.page_fault_store;
 }
 
-inline bool is_exception(InstUop uop) {
+inline bool is_exception(InstInfo uop) {
   return uop.page_fault_inst || uop.page_fault_load || uop.page_fault_store ||
          uop.illegal_inst || uop.type == ECALL;
 }
 
-inline bool is_flush_inst(InstUop uop) {
+inline bool is_exception(MicroOp uop) {
+  return uop.page_fault_inst || uop.page_fault_load || uop.page_fault_store ||
+         uop.illegal_inst || uop.type == ECALL;
+}
+
+inline bool is_flush_inst(InstInfo uop) {
+  return uop.type == CSR || uop.type == ECALL || uop.type == MRET ||
+         uop.type == SRET || uop.type == SFENCE_VMA || is_exception(uop) ||
+         uop.type == EBREAK || (uop.flush_pipe && is_load(uop));
+}
+
+inline bool is_flush_inst(MicroOp uop) {
   return uop.type == CSR || uop.type == ECALL || uop.type == MRET ||
          uop.type == SRET || uop.type == SFENCE_VMA || is_exception(uop) ||
          uop.type == EBREAK || (uop.flush_pipe && is_load(uop));
diff --git a/diff/ref.cpp b/diff/ref.cpp
index 21d29c2..7fd66ff 100644
--- a/diff/ref.cpp
+++ b/diff/ref.cpp
@@ -874,6 +874,13 @@ void RefCpu::RV32A() {
     }
   }
 
+  if (p_addr & 0x3) {
+    Assert((p_addr & 3) == 0 && "AMO address misaligned!");
+    illegal_exception = true;
+    exception(v_addr);
+    return;
+  }
+
   if (funct5 != 2) {
     state.store = true;
     state.store_addr = p_addr;
@@ -984,7 +991,7 @@ void RefCpu::RV32IM() {
   case number_3_opcode_jalr: { // jalr
     is_br = true;
     br_taken = true;
-    next_pc = (reg_rdata1 + immI(Instruction)) & 0xFFFFFFFC;
+    next_pc = (reg_rdata1 + immI(Instruction)) & 0xFFFFFFFE;
     state.gpr[reg_d_index] = state.pc + 4;
     break;
   }
@@ -1046,14 +1053,19 @@ void RefCpu::RV32IM() {
     if (page_fault_load) {
       exception(v_addr);
       return;
-
     } else {
+      uint32_t alignment_mask = (funct3 & 0x3) == 0 ? 0 : (funct3 & 0x3) == 1 ? 1 : 3;
+      Assert((p_addr & alignment_mask) == 0 && "Load address misaligned!");
       if (((p_addr & UART_ADDR_MASK) == UART_ADDR_BASE) ||
           ((p_addr & PLIC_ADDR_MASK) == PLIC_ADDR_BASE)) {
         is_mmio_load = true;
       }
 
       // Timer MMIO ç‰¹æ®Šå¤„ç†ï¼šä½¿ç”¨ oracle_timer ä¿æŒä¸ DUT åŒæ­¥
+      uint64_t data_l = (uint64_t)memory[p_addr >> 2];
+      uint64_t data_h = (uint64_t)memory[(p_addr >> 2) + 1];
+      uint64_t data64 = (data_h << 32) | data_l;
+
       uint32_t data;
       if (p_addr == 0x1fd0e000) {
         oracle_timer += 1000;
@@ -1061,12 +1073,10 @@ void RefCpu::RV32IM() {
       } else if (p_addr == 0x1fd0e004) {
         data = 0;
       } else {
-        data = memory[p_addr >> 2];
+        data = (uint32_t)(data64 >> ((p_addr & 0b11) * 8));
       }
-      uint32_t offset = p_addr & 0b11;
-      uint32_t size = funct3 & 0b11;
-      uint32_t sign = 0, mask;
-      data = data >> (offset * 8);
+    uint32_t size = funct3 & 0b11;
+    uint32_t sign = 0, mask;
       if (size == 0) {
         mask = 0xFF;
         if (data & 0x80)
@@ -1102,6 +1112,8 @@ void RefCpu::RV32IM() {
       exception(v_addr);
       return;
     } else {
+      uint32_t alignment_mask = (funct3 & 0x3) == 0 ? 0 : (funct3 & 0x3) == 1 ? 1 : 3;
+      Assert((p_addr & alignment_mask) == 0 && "Store address misaligned!");
       if (((p_addr & UART_ADDR_MASK) == UART_ADDR_BASE) ||
           ((p_addr & PLIC_ADDR_MASK) == PLIC_ADDR_BASE)) {
         is_mmio_store = true;
@@ -1155,17 +1167,17 @@ void RefCpu::RV32IM() {
       break;
     }
     case 1: { // slli
-      state.gpr[reg_d_index] = reg_rdata1 << immI(Instruction);
+      state.gpr[reg_d_index] = reg_rdata1 << (immI(Instruction) & 0x1F);
       break;
     }
     case 5: { // srli, srai
       switch (funct7) {
       case 0: { // srli
-        state.gpr[reg_d_index] = (uint32_t)reg_rdata1 >> immI(Instruction);
+        state.gpr[reg_d_index] = (uint32_t)reg_rdata1 >> (immI(Instruction) & 0x1F);
         break;
       }
       case 32: { // srai
-        state.gpr[reg_d_index] = (int32_t)reg_rdata1 >> immI(Instruction);
+        state.gpr[reg_d_index] = (int32_t)reg_rdata1 >> (immI(Instruction) & 0x1F);
         break;
       }
       }
@@ -1261,7 +1273,7 @@ void RefCpu::RV32IM() {
         break;
       }
       case 1: { // sll
-        state.gpr[reg_d_index] = reg_rdata1 << reg_rdata2;
+        state.gpr[reg_d_index] = reg_rdata1 << (reg_rdata2 & 0x1F);
         break;
       }
       case 2: { // slt
@@ -1281,11 +1293,11 @@ void RefCpu::RV32IM() {
       case 5: { // srl, sra
         switch (funct7) {
         case 0: { // srl
-          state.gpr[reg_d_index] = (uint32_t)reg_rdata1 >> reg_rdata2;
+          state.gpr[reg_d_index] = (uint32_t)reg_rdata1 >> (reg_rdata2 & 0x1F);
           break;
         }
         case 32: { // sra
-          state.gpr[reg_d_index] = (int32_t)reg_rdata1 >> reg_rdata2;
+          state.gpr[reg_d_index] = (int32_t)reg_rdata1 >> (reg_rdata2 & 0x1F);
           break;
         }
         }
@@ -1318,28 +1330,30 @@ void RefCpu::store_data() {
 
   uint32_t p_addr = state.store_addr;
   int offset = p_addr & 0x3;
-  uint32_t wstrb = state.store_strb << offset;
-  uint32_t wdata = state.store_data << (offset * 8);
-  uint32_t old_data = memory[p_addr / 4];
-  uint32_t mask = 0;
-
-  if (wstrb & 0b1)
-    mask |= 0xFF;
-  if (wstrb & 0b10)
-    mask |= 0xFF00;
-  if (wstrb & 0b100)
-    mask |= 0xFF0000;
-  if (wstrb & 0b1000)
-    mask |= 0xFF000000;
-  /*if ((number_funct3_unsigned == 1 && p_addr % 2 == 1) ||*/
-  /*    (number_funct3_unsigned == 2 && p_addr % 4 != 0)) {*/
-  /*  cout << "Store Memory Address Align Error!!!" << endl;*/
-  /*  cout << "funct3 code: " << dec << number_funct3_unsigned << endl;*/
-  /*  cout << "addr: " << hex << p_addr << endl;*/
-  /*  exit(-1);*/
-  /*}*/
-
-  memory[p_addr / 4] = (mask & wdata) | (~mask & old_data);
+  uint64_t wstrb = (uint64_t)state.store_strb << offset;
+  uint64_t wdata = (uint64_t)state.store_data << (offset * 8);
+
+  for (int i = 0; i < 2; i++) {
+    uint32_t current_wstrb = (wstrb >> (i * 4)) & 0xF;
+    uint32_t current_wdata = (wdata >> (i * 32)) & 0xFFFFFFFF;
+    if (current_wstrb == 0)
+      continue;
+
+    uint32_t mask = 0;
+    if (current_wstrb & 0b1)
+      mask |= 0xFF;
+    if (current_wstrb & 0b10)
+      mask |= 0xFF00;
+    if (current_wstrb & 0b100)
+      mask |= 0xFF0000;
+    if (current_wstrb & 0b1000)
+      mask |= 0xFF000000;
+
+    uint32_t old_data = memory[(p_addr >> 2) + i];
+    memory[(p_addr >> 2) + i] = (mask & current_wdata) | (~mask & old_data);
+  }
+
+  // UART and Interrupt logic follows...
 
   if (p_addr == UART_BASE) {
     char temp;
diff --git a/include/SimCpu.h b/include/SimCpu.h
index 5614884..dda9e40 100644
--- a/include/SimCpu.h
+++ b/include/SimCpu.h
@@ -19,6 +19,7 @@ public:
   void front_cycle();
   void back2front_comb();
   void back2mmu_comb();
+  uint32_t get_reg(uint8_t arch_idx) { return back.get_reg(arch_idx); }
 };
 
 extern SimCpu cpu;
diff --git a/main.cpp b/main.cpp
index f133f85..1c2b205 100644
--- a/main.cpp
+++ b/main.cpp
@@ -241,6 +241,12 @@ int main(int argc, char *argv[]) {
     // cpu.ctx.perf.perf_print(); // Handled by exit_handler
     cout << "\033[1;32m-----------------------------\033[0m" << endl;
 
+    if (cpu.ctx.exit_reason == ExitReason::EBREAK) {
+      uint32_t a0 = cpu.get_reg(10);
+      free(p_memory);
+      return a0;
+    }
+
   } else {
     cout << "\033[1;31m------------------------------\033[0m" << endl;
     cout << "\033[1;31mTIME OUT!!!!QAQ\033[0m" << endl;
